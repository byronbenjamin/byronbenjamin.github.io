<!DOCTYPE html>

<html>
<head>
  <link rel="stylesheet" type="text/css" href="../stylesheets/cheatsheet.css">
  <link href='https://fonts.googleapis.com/css?family=Noto+Serif:400,400italic|Arvo:400,400italic|Satisfy|Bad+Script' rel='stylesheet' type='text/css'>
  <title>Ruby Cheat Sheet</title>
</head>
<body>
  <header><h1>Ruby Cheat Sheet<h1></header>
  <section class="left">
    <h3>Ruby Basics</h3>
    <table class="table table-striped">
    <tbody><tr>
      <th class="concept">Concept</th>
      <th class="usage">Usage</th>
      <th class="example">Examples</th>
      <th class="description">Description</th>
    </tr>
    <tr>
      <td>Comment</td>
      <td>
        <code><strong>#</strong> <em>Comment text</em></code>
      </td>
      <td>
        <p>
          <code><strong>#</strong> <em>This text is a comment</em></code>
        </p>

        <p>
          <code>some.ruby_code <strong>#</strong> A comment</code>
        </p>

        <p>
          <code><strong>#</strong> some.ignored_ruby_code</code>
        </p>
      </td>
      <td>
        Ruby ignores everything that is marked as a comment. It does not try
        to execute it. Comments are just there for you as information.
        Comments are also commonly used to <em>comment out code</em>. That
        is when you don't want some part of your code to execute
        but you don't want to delete it just yet, because you are trying
        different things out.
      </td>
    </tr>
    <tr>
      <td>Variables</td>
      <td>
        <code><strong>variable =</strong> <em>some_value</em></code>
      </td>
      <td>
    <pre><code><strong>name =</strong> <em>"Tobi"</em>
    <strong>name</strong> # =&gt; "Tobi"</code></pre>
    <pre><code><strong>sum =</strong> <em>18 + 5</em>
    <strong>sum</strong> # =&gt; 23</code></pre>
      </td>
      <td>
        With a variable you tell Ruby that from now on you want to refer to
        that value by the name you gave it. So for the first example, from
        now on when you use <em>name</em> Ruby will know that you meant
        <em>"Tobi"</em>.
      </td>
    </tr>
    <tr>
      <td>Console output</td>
      <td>
        <code><strong>puts</strong> <em>something</em></code>
      </td>
      <td>
        <p><code><strong>puts</strong> <em>"Hello World"</em></code></p>

        <p><code><strong>puts</strong> <em>[1, 5, "mooo"]</em></code></p>
      </td>
      <td>
        Prints its argument to the console. Can be used in Rails apps
        to print something in the console where the server is running.
      </td>
    </tr>
    <tr>
      <td>Call a method</td>
      <td>
        <code>object<strong>.method</strong><em>(arguments)</em></code>
      </td>
      <td>
        <p><code>string<strong>.length</strong></code></p>

        <p><code>
          array<strong>.delete_at</strong><em>(2)</em>
        </code></p>

        <p><code>string<strong>.gsub</strong><em>("ae", "ä")</em></code></p>
      </td>
      <td>
        <p>Calling a method is also often referred to as
          <em>sending a message</em> in Ruby. Basically we are sending an
          object some kind of message and are waiting for its response.
          This message may have no arguments or multiple arguments, depending
          on the message.
          So we kindly ask the object to do something or give us some
          information.
          When you "call a method" or "send a message" something happens. In the
          first example we ask a String how long it is (how many
          characters it consists of). In the last example we substitute all
          occurrences of "ae" in the string with the German "ä".</p>

        <p>
          Different kinds of objects (Strings, Numbers, Arrays...)
          understand different messages.
        </p>
      </td>
    </tr>
    <tr>
      <td>Define a method</td>
      <td>
    <pre><code><strong>def</strong> <em>name(parameter)</em>
      <em># method body</em>
    <strong>end</strong></code></pre>
      </td>
      <td>
    <pre><code><strong>def</strong> <em>greet(name)</em>
      <em>puts "Hi there " + name</em>
    <strong>end</strong></code></pre>
      </td>
      <td>
        <p>Methods are basically reusable units of behaviour. And you can
          define them yourself just like this. Methods are small and focused
          on implementing a specific behaviour.</p>

        <p>
          Our example method is focused on greeting people.
          You could call it like this: <code>greet("Tobi")</code>
        </p>
      </td>
    </tr>
    <tr>
      <td>Equality</td>
      <td><code>object <strong>==</strong> other</code></td>
      <td>
        <p><code>true <strong>==</strong> true # =&gt; true</code></p>

        <p><code>3 <strong>==</strong> 4 # =&gt; false</code></p>

        <p><code>"Hello" <strong>==</strong> "Hello" # =&gt; true</code></p>

        <p><code>"Helo" <strong>==</strong> "Hello" # =&gt; false</code></p>
      </td>
      <td>
        With two equal signs you can check if two things are the
        same. If so, <code>true</code> will be returned; otherwise, the result
        will be <code>false</code>.
      </td>
    </tr>
    <tr>
      <td>Inequality</td>
      <td><code>object <strong>!=</strong> other</code></td>
      <td>
        <p><code>true <strong>!=</strong> true # =&gt; false</code></p>

        <p><code>3 <strong>!=</strong> 4 # =&gt; true</code></p>
      </td>
      <td>
        Inequality is the inverse to equality, e.g. it results in
        <code>true</code> when two values are not the same and it results
        in <code>false</code> when they are the same.
      </td>
    </tr>
    <tr>
      <td>Decisions with if</td>
      <td>
    <pre><code><strong>if</strong> <em>condition</em>
      # happens when true
    <strong>else</strong>
      # happens when false
    <strong>end</strong>
    </code></pre>
      </td>
      <td>
    <pre><code><strong>if</strong> <em>input == password</em>
      grant_access
    <strong>else</strong>
      deny_access
    <strong>end</strong>
    </code></pre>
      </td>
      <td>
        <p>With if-clauses you can decide based upon a <em>condition</em>
          what to do. When the condition is considered true, then the code
          after it is executed. If it is considered false, the code after
          the "else" is executed.</p>

        <p>
          In the example, access is granted based upon the decision if a
          given input matches the password.
        </p>
      </td>
    </tr>
    <tr>
      <td>Constants</td>
      <td><code><strong>CONSTANT =</strong> <em>some_value</em></code></td>
      <td>
    <pre><code><strong>PI = 3.1415926535</strong>
    <strong>PI</strong> # =&gt; 3.1415926535</code></pre>
    <pre><code><strong>ADULT_AGE</strong> = 18
    <strong>ADULT_AGE</strong> # =&gt; 18</code></pre>
      </td>
      <td>
        Constants look like variables, just in UPCASE. Both hold
        values and give you a name to refer to those values. However while
        the value a variable holds may change or might be of an unknown
        value (if you save user input in a variable) constants are
        different. They have a known value that should never change. Think
        of it a bit like mathematical or physical constants. These don't
        change, they always refer to the same value.
      </td>
    </tr>
    </tbody></table>
      </section>
      <section class="right">
        <h3>Arrays</h3>
        <table class="table table-striped">
      <tbody><tr>
        <th class="concept">Concept</th>
        <th class="usage">Usage</th>
        <th class="example">Examples</th>
        <th class="description">Description</th>
      </tr>
      <tr>
        <td>Create</td>
        <td>
          <code><strong>[</strong><em>contents/data</em><strong>]</strong></code>
        </td>
        <td>
          <p><code><strong>array = []</strong></code></p>
          <p><code><strong>array = Array.new</strong></code></p>

          <p><code>
            <strong>[</strong><em>"Rails", "fun", 5</em><strong>]</strong>
          </code></p>
        </td>
        <td>Creates an Array, empty or with the specified contents.</td>
      </tr>
      <tr>
        <td>Number of elements</td>
        <td>
          <code>array<strong>.size</strong></code>
        </td>
        <td>
          <p><code>[]<strong>.size</strong> # =&gt; 0</code></p>

          <p><code>[1, 2, 3]<strong>.size</strong> # =&gt; 3</code></p>

          <p><code>["foo", "bar"]<strong>.size</strong> # =&gt; 2</code></p>
        </td>
        <td>Returns the number of elements in an Array.</td>
      </tr>
      <tr>
        <td>Access</td>
        <td>
          <code>
            array<strong>[</strong><em>position</em><strong>]</strong>
          </code>
        </td>
        <td>
    <pre><code>array = ["hi", "foo", "bar"]
    array<strong>[</strong><em>0</em><strong>]</strong> # =&gt; "hi"
    array<strong>[</strong><em>2</em><strong>]</strong> # =&gt; "bar"</code></pre>
        </td>
        <td>As an Array is a collection of different elements, you often want
          to access a single element of the Array.
          Arrays are indexed by numbers so you can use a number
          to access an individual element. Be aware that the
          numbering actually starts with "0" so the first element
          actually is the 0th. And the last element of a three element
          array is element number 2.
        </td>
      </tr>
      <tr>
        <td>Adding an element</td>
        <td>
          <code>array <strong>&lt;&lt;</strong> <em>element</em></code>
        </td>
        <td>
    <pre><code>array = [1, 2, 3]
    array <strong>&lt;&lt;</strong> <em>4</em>
    array # =&gt; [1, 2, 3, 4]
    </code></pre>
        </td>
        <td>
          Adds the element to the end of the array,
          increasing the size of the array by one.
        </td>
      </tr>
      <tr>
        <td>Assigning</td>
        <td>
          <code>array<strong>[</strong><em>number</em><strong>] =
          </strong> <em>value</em></code>
        </td>
        <td>
    <pre><code>array = ["hi", "foo", "bar"]
    array<strong>[</strong><em>2</em><strong>] =</strong> <em>"new"</em>
    array # =&gt; ["hi", "foo", "new"]</code></pre>
        </td>
        <td>Assigning new Array Values works a lot like accessing
          them; use an equals sign to set a new value. Voila!
          You changed an element of the array! Weehuuuuu!
        </td>
      </tr>
      <tr>
        <td>Delete at index</td>
        <td><code>
          array<strong>.delete_at</strong><em>(i)</em>
        </code></td>
        <td>
    <pre><code>array = [0, 14, 55, 79]
    array<strong>.delete_at</strong><em>(2)</em>
    array # =&gt; [0, 14, 79]
    </code></pre>
        </td>
        <td>
          Deletes the element of the array at the specified index. Remember
          that indexing starts at 0. If you specify an index larger than the
          number of elements in the array, nothing will happen.
        </td>
      </tr>
      <tr>
        <td>Iterating</td>
        <td>
          <code>array<strong>.each</strong> <em>do |e| .. end</em></code>
        </td>
        <td>
          <p><code>
            persons<strong>.each</strong> <em>do |p| puts p.name end</em>
          </code></p>

          <p><code>
            numbers<strong>.each</strong> <em>do |n| n = n * 2 end</em>
          </code></p>
        </td>
        <td>
          <p>
            "Iterating" means doing something for <em>each</em> element
            of the array. Code placed between <em>do</em> and <em>end</em>
            determines what is done to each element in the array.
          </p>

          <p>
            The first example prints the name of every person in the array to
            the console. The second example simply doubles every number of a
            given array.
          </p>
        </td>
      </tr>
    </tbody></table>
    <h3>Hashes</h3>
    <table class="table table-striped">
      <tbody><tr>
        <th class="concept">Concept</th>
        <th class="usage">Usage</th>
        <th class="hash-example">Examples</th>
        <th class="description">Description</th>
      </tr>
      <tr>
        <td>Creating</td>
        <td><code>
          <p><strong>hash = {}</strong></p>
          <p> <strong>hash = Hash.new</strong></p>

        </code></td>
        <td>
          <p><code>
            <strong>{</strong>:hobby <strong>=&gt;</strong>
            "programming"<strong>}</strong>
          </code></p>
    <pre><code><strong>{</strong>42 <strong>=&gt;</strong> "answer", "score" <strong>=&gt;</strong> 100,
     :name <strong>=&gt;</strong> "Tobi"<strong>}</strong>
    </code></pre>
        </td>
        <td>
          You create a hash by surrounding the key-value pairs with curly
          braces. The arrow always goes from the <em>key</em> to the
          <em>value</em> depicting the meaning: <em>"This key points to this
          value."</em>. Key-value pairs are then separated by commas.
        </td>
      </tr>
      <tr>
        <td>Accessing</td>
        <td><code>hash<strong>[</strong>key<strong>]</strong></code></td>
        <td>
    <pre><code>hash = {:key =&gt; "value"}
    hash<strong>[</strong>:key<strong>]</strong> # =&gt; "value"
    hash<strong>[</strong>foo<strong>]</strong> # =&gt; nil
    </code></pre>
        </td>
        <td>
          Accessing an entry in a hash looks a lot like accessing it in
          an <em>array</em>. However with a hash the key can be anything, not
          just numbers. If you try to access a key that does not exist, the
          value <code>nil</code> is returned, which is Ruby's way of saying
          "nothing", because if it doesn't recognize the key it can't return
          a value for it.
        </td>
      </tr>
      <tr>
        <td>Assigning</td>
        <td>
          <code>hash<strong>[</strong>key<strong>] =</strong> value</code>
        </td>
        <td>
    <pre><code>hash = {:a =&gt; "b"}
    hash<strong>[</strong>:key<strong>] =</strong> "value"
    hash # =&gt; {:a=&gt;"b", :key=&gt;"value"}
    </code></pre>
        </td>
        <td>
          Assigning values to a hash is similar to assigning values to an
          array. With a hash, the key can
          be a number or it can be a symbol, string,
          number... or anything, really!
        </td>
      </tr>
      <tr>
        <td>Deleting</td>
        <td><code>hash<strong>.delete</strong><em>(key)</em></code></td>
        <td>
    <pre><code>hash = {:a =&gt; "b", :b =&gt; 10}
    hash<strong>.delete</strong><em>(:a)</em>
    hash # =&gt; {:b=&gt;10}
    </code></pre>
        </td>
        <td>
          You can delete a specified key from the hash, so that the key and its
          value can not be accessed.
        </td>
      </tr>
    </tbody></table>
  </section class="bottom">
    <h3>Frequently Used Methods</h3>
    <table class="table table-striped">
      <tbody><tr>
        <th class="method">Methods</th>
        <th class="hash-example">Examples</th>
        <th class="description">Description</th>
      </tr>
      <tr>
        <td>.each</td>
        <td><code>
          <p># prints 246810 and returns [1, 2, 3, 4, 5]</p>
          <p>[1, 2, 3, 4, 5].each {|x| print x*2}</p>

        </code></td>
        <td>
          executes block and returns the list of objects without mutating
        </td>
      </tr>
      <tr>
        <tr>
        <td>.map</td>
        <td><code>
          <p># prints 246810 and returns [1, 2, 3, 4, 5]</p>
          <p>[1, 2, 3, 4, 5].each {|x| print x*2}</p>

        </code></td>
        <td>
          executes block and returns the list of mutated objects
        </td>
      </tr>
      <tr>
        <td>.select</td>
        <td><code>
          <p>[1, 2, 3, 4, 5].select {|x| x==2}</p>
          <p># => [2] </p>
        </code></td>
        <td>
          returns a list of objects when condition is true
        </td>
      </tr>
      <tr>
        <td>.reject</td>
        <td><code>
          <p>[1, 2, 3, 4, 5].reject {|x| x==2}</p>
          <p># => [1, 3, 4, 5] </p>
        </code></td>
        <td>
          returns a list of objects when condition is false
        </td>
      </tr>
      <tr>
        <td>.uniq</td>
        <td><code>
          <p>[1, 2, 3, 3, 3, 4].uniq</p>
          <p> # => [1, 2, 3, 4] </p>
        </code></td>
        <td>
          returns a list without duplicates
        </td>
      </tr>
      <tr>
        <td>.reverse</td>
        <td><code>
          <p>[1, 2, 3, 4].reverse</p>
          <p># => [4, 3, 2, 1] </p>
        </code></td>
        <td>
          reverse the list
        </td>
      </tr>
      <tr>
        <td>.compact</td>
        <td><code>
          <p>[1, 2, 3, nil, nil, 4].compact</p>
          <p># => [1, 2, 3, 4]</p>
        </code></td>
        <td>
          return all non-nil objects
        </td>
      </tr>
      <tr>
        <td>.flatten</td>
        <td><code>
          <p>[[3,2], [4,4]].flatten</p>
          <p># => [3, 2, 4, 4]</p>
        </code></td>
        <td>
          flatten inner arrays
        </td>
      </tr>
      <tr>
        <td>.partition</td>
        <td><code>
          <p>[1, 4, 5, 6].partition {|x| x==4||x==5}</p>
          <p> # => [[4, 5], [1, 6]] </p>
        </code></td>
        <td>
          create two collections. First collection for true, second for false.
        </td>
      </tr>
      <tr>
        <td>.sort</td>
        <td><code>
          <p>[31, 34, 11, 23, 1, 3].sort</p>
          <p># => [1, 3, 11, 23, 31, 34]</p>
        </code></td>
        <td>
          sorts the list
        </td>
      </tr>
  <section>
  </section>
</body>
</html>